"use strict";function e(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}const t=e=>{if(!e)return null;const n={};switch(e.type){case"ELEMENT":{let s={};const a=E(e.value.attributes),T=t(e.value.children);if(a&&(s=Object.assign(s,a)),T){const t=r(e.value.children);s=Object.assign(s,t)}n[e.value.type]=s;break}case"ATTRIBUTE":{const t=e.value;n[t.name]=t.value;break}case"CONTENT":return{content:e.value}}return n},r=e=>e&&Array.isArray(e)&&0!==e.length?n(e)?{content:e[0].value}:{children:e.map(t)}:null,n=e=>e&&Array.isArray(e)&&1===e.length&&"CONTENT"===e[0].type,E=e=>{if(e&&Array.isArray(e)){return e.map(t).reduce(((e,t)=>Object.assign(e,t)),{})}return null};var s={convert:e=>t(e.value.children[0])};var a={Token:(e,t)=>({type:e,value:t}),TOKEN_TYPE:{OPEN_BRACKET:"OPEN_BRACKET",ELEMENT_TYPE:"ELEMENT_TYPE",CLOSE_ELEMENT:"CLOSE_ELEMENT",ATTRIB_NAME:"ATTRIB_NAME",ATTRIB_VALUE:"ATTRIB_VALUE",ASSIGN:"ASSIGN",CLOSE_BRACKET:"CLOSE_BRACKET",CONTENT:"CONTENT",EOF:"EOF"}};const{Token:T,TOKEN_TYPE:u}=a,c=T("EOF"),l=e=>" "===e||"\n"===e||"\r"===e||"\t"===e,o=e=>e.replace(/'/g,'"');var N={createLexer:function(e){let t=null,r=(e=>{let t=0;for(;t<e.length&&l(e[t]);)t++;return((e,t)=>{if(e.startsWith("<?xml",t)){const r=e.length;for(;t<r;)if("?"!==e[t])t++;else{if(">"===e[t+1])return t+2;t++}}return t})(e,t)})(e),n=[];const E=()=>e[r],s=()=>t!==c&&r<e.length,a=e=>'"'===e||"'"===e,N=()=>{for(;s()&&l(e[r]);)r++},i=t=>{if(s()){if("<"===e[r]){let t="<";return r++,s()&&"/"===e[r]?(r++,t="</"):s()&&"!"===e[r]&&"-"===e[r+1]&&"-"===e[r+2]&&(r++,r++,r++,t="\x3c!--"),t}if("/"===E()){let e="/";return r++,s()&&">"===E()&&(r++,e="/>"),e}if("="===e[r]||">"===e[r]){const t=e[r];return r++,t}}return p(!!t)},p=t=>{const n=t?/[^>=<]/u:/[a-zA-Z0-9_:-]/;let E=r;for(;s()&&e[r].match(n);)r++;return o(e.substring(E,r))},O=()=>{const l=r;N();const A=r-l;if(s())if(t&&t.type===u.OPEN_BRACKET){N();const e=i(!1);t=T(u.ELEMENT_TYPE,e),n.push(e)}else if(t&&t.type===u.ASSIGN){s()&&a(E())&&r++;let n=r;for(;s()&&!a(E());)r++;const c=o(e.substring(n,r));r++,t=T(u.ATTRIB_VALUE,c)}else{N();let a=i(!0);switch(a){case"=":t=t.type===u.ATTRIB_NAME?T(u.ASSIGN):T(u.CONTENT,a);break;case"</":{const E=r;for(;">"!==e[r];)r++;t=T(u.CLOSE_ELEMENT,e.substring(E,r)),r++,n.pop();break}case"/>":{const e=n.pop();t=T(u.CLOSE_ELEMENT,e);break}case"\x3c!--":{const t=["!","-","-"];for(;s()&&(">"!==t[2]||"-"!==t[1]||"-"!==t[0]);)t.shift(),t.push(e[r]),r++;return O()}case">":t=T(u.CLOSE_BRACKET);break;case"<":t=T(u.OPEN_BRACKET);break;default:if(a&&a.length>0){if(t.type===u.CLOSE_BRACKET){let e="";"<"!==E()&&(e=p(!0)),t=T(u.CONTENT,a+e)}else if(t.type!==u.ATTRIB_NAME&&t.type!==u.CONTENT)t.type===u.CLOSE_ELEMENT?(a=" ".repeat(A)+a,t=T(u.CONTENT,a)):t=T(u.ATTRIB_NAME,a);else{const e=" ".repeat(A)+a;t=T(u.CONTENT,e)}break}{const t='Unknown Syntax : "'+e[r]+'"';throw new Error(t)}}}else t=c;return t};return{peek:E,next:O,hasNext:s}}};const{createLexer:i}=N,{Token:p,TOKEN_TYPE:O}=a,[A,f,C,h]=["ROOT","ELEMENT","ATTRIBUTE","CONTENT"],_=(e,t)=>({type:e,value:t}),L=e=>_(h,e),y=(e,t,r)=>_(f,{type:e,attributes:t,children:r}),v=(e,t)=>_(C,{name:e,value:t}),S=(e,t)=>{const r=[];for(;e.hasNext();){const n=e.next();switch(n.type){case O.OPEN_BRACKET:{const t=e.next(),[n,E]=R(e);let s=[];E.type!==O.CLOSE_ELEMENT&&(s=S(e,t)),s&&s.length>0&&s[0].type===O.CONTENT&&(s=b(s)),r.push(y(t.value,n,s));break}case O.CLOSE_ELEMENT:if(n.value===t.value)return r;break;case O.CONTENT:r.push(L(n.value));break;case O.EOF:return r;default:throw new Error(`Unknown Lexem type: ${n.type} "${n.value}, scoping element: ${t.value}"`)}}return r},R=e=>{const t=[];let r=e.peek();if(!e.hasNext()||r&&r.type===O.CLOSE_BRACKET||r&&r.type===O.CLOSE_ELEMENT)return[t,r];for(r=e.next();e.hasNext()&&r&&r.type!==O.CLOSE_BRACKET&&r.type!==O.CLOSE_ELEMENT;){const n=r;e.next();const E=e.next(),s=v(n.value,E.value);t.push(s),r=e.next()}return[t,r]};function b(e){let t=[],r="";return e.forEach((e=>{e.type===O.CONTENT?r+=e.value:(r.length&&(t.push(L(r)),r=""),t.push(e))})),r.length&&t.push(L(r)),t}var B={transpile:function(e,t){const r=(e=>_(A,{children:S(e,p(A,"ROOT"))}))(i(e));return t?t.convert(r):r},Node:_,ElementNode:y,AttribNode:v};const M=s,{transpile:x}=B;var k=e({convertXML:function(e,t){return x(e,t||M)},createAST:function(e){return x(e)}});module.exports=k;
